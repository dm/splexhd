/*******************************************************************
(C) 2011 by Radu Stefan
radu124@gmail.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*******************************************************************/  
  
interface

uses includes;

class MESSAGEWRITER
{
public:
	MESSAGEWRITER(FILE *f):fou(f),contents(""),pos(0){;}
	MESSAGEWRITER & operator ,(const string b);
	MESSAGEWRITER & operator ,(const char * b);
	MESSAGEWRITER & operator ,(unsigned int b);
	MESSAGEWRITER & operator ,(int b);
	MESSAGEWRITER & operator ,(float b);
	MESSAGEWRITER & operator ,(double b);
	~MESSAGEWRITER();
	int skiptochar(string);
	FILE *fou;
	string contents;
	int pos;
	int ipos;
	int lpos;
	string modifier;
};

#define __COND_DBG_OUT(cond,...) do { if (!cond) break; { MESSAGEWRITER __MW(stderr); __MW , __VA_ARGS__; }} while(0)

#define __FILE_OUT(fou,...) do { {MESSAGEWRITER __MW(fou); __MW , __VA_ARGS__;} } while(0)

#define assume(cond,msg) \
	do { if (cond) break; \
	{ MESSAGEWRITER __MW(stderr); __MW , "\n!!! ERROR !!! in " ,__func__ ,"() at " , __FILE__ ,":",__LINE__ , "\n" , msg , "\n\n"; \
	} assert(0); } while(0)

#define assret(cond,msg) \
	do { if (cond) break; \
	{ MESSAGEWRITER __MW(stderr); __MW , "\n!!! FAIL !!! in " ,__func__ ,"() at " , __FILE__ ,":",__LINE__ , "\n" , msg , "\n\n"; \
	} return 0; } while(0)
	
#define warnif(cond,msg) \
	do { if (!cond) break; \
	{ MESSAGEWRITER __MW(stderr); __MW , "\n!!! WARNING !!! in " ,__func__ ,"() at " , __FILE__ ,":",__LINE__ , "\n" , msg , "\n\n"; \
	} } while(0)

#define assume_paranoid(cond,msg) assume(cond,msg)

#ifdef DISABLEMESSAGES
int MSG_DISABLE_ALL=1;
#else
int MSG_DISABLE_ALL=0;
#endif

/// required-produced matrix
const int ML_QUIET_REQWARN=0;
const int ML_QUIET_REQINFO=0;
const int ML_QUIET_REQDBG=0;

const int ML_WARN_REQWARN=1 && !MSG_DISABLE_ALL;
const int ML_WARN_REQINFO=0;
const int ML_WARN_REQDBG=0;

const int ML_INFO_REQWARN=1 && !MSG_DISABLE_ALL;
const int ML_INFO_REQINFO=1 && !MSG_DISABLE_ALL;
const int ML_INFO_REQDBG=0;

const int ML_DBG_REQWARN=1 && !MSG_DISABLE_ALL;
const int ML_DBG_REQINFO=1 && !MSG_DISABLE_ALL;
const int ML_DBG_REQDBG=1 && !MSG_DISABLE_ALL;


#define LEV_QUIET(a) ML_QUIET_##a

#ifndef ALLQUIET

#define LEV_INFO(a) ML_INFO_##a
#define LEV_WARN(a) ML_WARN_##a
#define LEV_DBG(a) ML_DBG_##a

#else

#define LEV_INFO(a) ML_QUIET_##a
#define LEV_WARN(a) ML_QUIET_##a
#define LEV_DBG(a) ML_QUIET_##a

#endif


#define INFO(tgt,...) __COND_DBG_OUT(MSG_##tgt(REQINFO),__VA_ARGS__)
#define WARN(tgt,...) __COND_DBG_OUT(MSG_##tgt(REQWARN),__VA_ARGS__)
#define DBG(tgt,...) __COND_DBG_OUT(MSG_##tgt(REQDBG),__VA_ARGS__)
#define MESSAGE(...) __FILE_OUT(stdout,__VA_ARGS__)


implementation

int MESSAGEWRITER::skiptochar(string c)
{
	ipos=pos;
	modifier="%";
	modifier+=c[0];
	while (pos<contents.length())
	{
		if (contents[pos++]!='%') continue;
		lpos=pos-1;
		if (contents[pos]=='%') { pos++; continue; }
		while (isdigit(contents[pos]) || contents[pos]=='.') pos++;
		if (c.find(contents[pos])==string::npos)
		{
			fprintf(fou,"!!! bad output qualifier %c, expecting \"%s\"!!!",contents[pos],c.c_str());
			return 0;
		}
		modifier=contents.substr(lpos,pos-lpos+1);
		fprintf(fou,"%s",contents.substr(ipos,lpos-ipos).c_str());
		pos++;
		return 1;
	}
	fprintf(fou,"%s",contents.substr(ipos).c_str());
	contents="";
	pos=0;
	return 0;
}

MESSAGEWRITER & MESSAGEWRITER::operator ,(const string b)
{
	if (skiptochar("s")) fprintf(fou,modifier.c_str(),b.c_str());
	else contents+=b;
	return *this;
}

MESSAGEWRITER & MESSAGEWRITER::operator ,(const char * b)
{
	if (skiptochar("s")) fprintf(fou,modifier.c_str(),b);
	else contents+=b;
	return *this;
}

MESSAGEWRITER & MESSAGEWRITER::operator ,(unsigned int b)
{
	skiptochar("cxd");
	fprintf(fou,modifier.c_str(),b);
	return *this;
}

MESSAGEWRITER & MESSAGEWRITER::operator ,(int b)
{
	skiptochar("cxd");
	fprintf(fou,modifier.c_str(),b);
	return *this;
}

MESSAGEWRITER & MESSAGEWRITER::operator ,(float b)
{
	skiptochar("f");
	fprintf(fou,modifier.c_str(),b);
	return *this;
}

MESSAGEWRITER & MESSAGEWRITER::operator ,(double b)
{
	skiptochar("f");
	fprintf(fou,modifier.c_str(),b);
	return *this;
}

MESSAGEWRITER::~MESSAGEWRITER()
{
	fprintf(fou,"%s",contents.c_str()+pos);
}

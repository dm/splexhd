interface

uses includes;

int lvlshowdispi=0;
int lvlshowdispj=0;
int lastframetime=0;
int thisframetime;
int tcnti,tcntj;
int relyonrefresh=0;
int slomo=0;
int slocount=20;
int expectedtimeperframe=5000;

void startgame();

uint32_t timenow=0;
uint32_t timestarted=0;
uint32_t showlevstat=3;

void playGame();
void initLevel();
void repairBorder();
void countDown();
void doObjects();

uint64_t timerfreq=0;

/**
 * returns the progress of an object through animation
 * @param counter    - the object counter
 * @param maxcounter - the maximum value of the counter
 * @param animstart - value at the start of the animation
 * @param animstop  - the value at the end of animation, for example if animstart is 0 and animstop is 100 then the result in in percent
 */
int animprogress(int counter, int maxcounter, int animstart, int animstop=0);

implementation

uses gamedata, timing, loadlevel, objBug, objConsole, objExplosion, objKnik, objOrange, objZonk;

uint32_t gettimeuseconds();
int appIdle();
int getdemomove();
void startgame();
void gamekeypressed(int);
void endgame();

int animprogress(int counter, int maxcounter, int animstart, int animstop)
{
	return animstart+(animstop-animstart)*(maxcounter-counter)/maxcounter;
}

int getdemomove()
{
	if (demo.frame>=timing.m1) demo.frame=0;
	// if it's one of the 8 times that movement is sampled
	if (timing.isoct(demo.frame))
	{
		if (!demo.mcnt)
		{
			demo.move=demo.dat[demo.pos++];
			if (demo.move==0xff)
			{
				demo.length=0;
				return 0;
			}
			demo.mcnt=(demo.move>>4)+1;
			demo.move&=0x0f;
		}
		demo.mcnt--;
	}
	demo.frame++;
	if (demo.move>9) return 0;
	return demo.move;
}

void startgame()
{
	if (!loadLevel("data/levels/orig-012.sp")) return;
}

void endgame()
{
}

void renderframe()
{
}

int appIdle()
{
/*
	if (menumode || !appActive) return 1;
	zoomOnMurphy();

	//lastframetime=gettimeuseconds();
	renderframe();
	thisframetime=gettimeuseconds();
	timenow=gettimeuseconds();
	if (gamemode==GAMEMODE_NORMAL)
	{
		if ((thisframetime-lastframetime)>200000) thisframetime=lastframetime+10000;
		if (relyonrefresh) playGame();
		else while ((thisframetime-lastframetime)>6000)
		{
			lastframetime+=expectedtimeperframe;
			playGame();
		}
	}
*/
	return 0;
}

void playGame()
{
	/*
	if (slomo)
	{
		if (slocount-- >0) return;
		slocount=80;
	}
	if (gamelost&&(!endgamecountdown)) endgamecountdown=100;
	if (endgamecountdown)
	{
		endgamecountdown--;
		if (!endgamecountdown)
		{
			switchtomenumode();
			return;
		}
	}
	if (moviefile!=-1)
	{
		ldt[0].b.extra=lastactionkey;
		_write(moviefile,ldt,sizeof(ldt));
		ldt[0].b.extra=0;
	}
	doMurphy();
	zoomOnMurphy();
	*/
	if (game.timenow-game.timelastmove>50) doObjects();
}



void doObjects()
{
	game.timelastmove=game.timenow;
	int i,typ,tb,tf;
	for (i=lvlwidth+1; i<(lvlheight-1)*lvlwidth; i++)
	{
		int cnt=ldt[i].counter;
		if (cnt) ldt[i].counter=--cnt;
		typ=ldt[i].typ;
		tb=typ & 0xf0;
		tf=typ & 0xff;
		if (!cnt && tb==TX_MOVEOUT)
			ldt[i].typ=tb=typ=0;
		// call the appropriate function based on object time
		if (typ & TF_ORANGE) doobj_orange(i);
		else if (typ & TF_FALLING) doobj_zonk(i);
		else if (tb == TX_KNIK || tb==TX_ELECTRON)   doobj_knik(i);
		else if (tf == TX_EXPLOSION) doobj_explosion(i);
	}
}

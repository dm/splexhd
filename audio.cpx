/*******************************************************************
(C) 2011 by Radu Stefan
radu124@gmail.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*******************************************************************/  
  
interface

uses includes;

void init_audio();
int load_effects(string fn);
int song_start(string path, int paused=0);
void song_stop();
void audio_yield();
double song_time();
void effect_start(int effnum, int channel=0, int volume=256);

int callbacklen;
SDL_AudioSpec desired, obtained;

implementation

uses verbosity, message, utils;

// this is not defined under Windows, at least in my version of libvorbis
int ov_myfopen(char *path,OggVorbis_File *vf)
{
	FILE *fin;
#ifdef _WINDOWS
	fin=fopen(path,"rb");
#else
	fin=fopen(path,"r");	
#endif
	ov_open(fin,vf,NULL,0);
}

struct tEffects
{
	int count;
	int16_t *data[256];
	int len[256];
	tEffects():count(0) { int i; for (i=0; i<256; i++) {data[i]=NULL; len[i]=0; } }
};

const int SONG_BUFFER_SIZE=262144;
const int SONG_MARGIN=16384;
const int SONG_STARTAFTER=44100;

struct tPlaying
{
	int effectid[8];
	int effectvol[8];
	int effectchn[8];
	int effectpos[8];
	volatile int startpaused;
	volatile int playpos;
	volatile int decodepos;
	volatile int stopsat;
	volatile int sisopen;
	volatile int refreshsong;
	volatile int loopsong;
	volatile int playing;
	volatile int pause;
	volatile int songstarted;
	volatile int stalled;
	volatile int songended;
	int ogg_bs;
	int decode_lasttime;
	int decode_ticks;
	
	OggVorbis_File ov_song;
	
	int16_t buffer[2][SONG_BUFFER_SIZE];
	char songname[2048];
	void close_song();
	void open_song();
	void some_predecode();
	void close_ovfile(OggVorbis_File *ovf);
	int decode(OggVorbis_File *ovf);
};

tEffects effects;
tPlaying playing;
const int BUF_SIZE=1024;
int mixbuffer_l[BUF_SIZE];
int mixbuffer_r[BUF_SIZE];

int pbpos=0;

int min3(int a, int b, int c)
{
	if (a<b && a<c) return a;
	if (b<c) return b;
	return c;
}

int rangelimit(int a)
{
	if (a<-32760) return -32760;
	if (a>32760) return 32760;
	return a;
}

/**
 * Mix song output and effects
 */
void my_audio_callback(void *userdata, Uint8 *stream, int len)
{
	int i,decodebtm;
	int16_t *streamS=(int16_t *) stream;
	int poslong=playing.playpos;
	int pos=poslong%SONG_BUFFER_SIZE;
	
	callbacklen=len;
	decodebtm=playing.decodepos; 
	
	// Playback was stalled but the buffer was refilled in the mean time
	// resume playing
	if (playing.stalled && decodebtm>playing.playpos+SONG_STARTAFTER) 
	{
		playing.playing=1;
		playing.stalled=0;
		DBG(AUDIO,"unstalled\n");
	}
	
	// Playback reached the end of the song
	// stop playing
	if (poslong>playing.stopsat && poslong>playing.stopsat)
	{
		playing.playing=0;
		playing.songended=1;
	}
	
	// not enough data to play in the decode buffer
	// suspend playing
	if (playing.playing && decodebtm<playing.playpos+len/4)
	{
		playing.stalled=1;
		playing.playing=0;
		DBG(AUDIO,"stalled\n");
	}
	
	int en_play=(playing.playing);
	int vol1, vole0, vole1;
	
	int16_t *effs[8];
	int16_t *eff0=NULL;
	int16_t *eff1=NULL;
	vole0=85;
	vole1=85;
	vol1=85;
	
	for (i=0; i<8; i++)
	{
		effs[i]=NULL;
		if (playing.effectid[i]>0)
		{
			int eid=playing.effectid[i];
			int epos=playing.effectpos[i];
			if (effects.len[eid]<epos+len/4) 
			{	
				playing.effectid[i]=0;
			} else effs[i]=effects.data[eid]+epos;
			playing.effectpos[i]+=len/4;
		}
	}
	eff0=effs[0];
	eff1=effs[1];
	if (playing.pause) en_play=0;
	for (i=0; i<len/4; i++)
	{
		int s=0;
		
		if (en_play)
			s+=vol1*playing.buffer[0][pos];

		if (eff0) s+=vole0* *eff0;
		if (eff1) s+=vole0* *eff1;
		streamS[i*2]=rangelimit(s/256);
		
		s=0;
	
		if (en_play)
			s+=vol1*playing.buffer[1][pos];

		if (eff0) s+=vole0* *eff0++;
		if (eff1) s+=vole0* *eff1++;
		streamS[i*2+1]=rangelimit(s/256);
		
		pos=(pos+1)%SONG_BUFFER_SIZE;
	}
	if (en_play)
		playing.playpos+=len/4;
}

void effect_start(int effnum, int channel, int volume)
{
	static int alternate=0;
	if (!effnum) return;
	playing.effectpos[alternate]=0;
	playing.effectid[alternate]=effnum;
	alternate^=1;
}

void init_audio()
{
	desired.freq=44100;
	desired.format=AUDIO_S16SYS;
	desired.samples=BUF_SIZE;
	desired.channels=2;
	desired.userdata=(void *) &playing;
	desired.callback=my_audio_callback;
	assume(SDL_OpenAudio(&desired, &obtained)>=0, "Couldn't open audio: %s\n");
	SDL_PauseAudio(0);
}

int16_t interpolate(int16_t *buf, int pos, int chn=1)
{
	return buf[pos/256];
}

int load_effects(string fn)
{
	int padding=BUF_SIZE;
	int16_t buf[4112];
	int bs=0;
	int i,j,v;
	int pos=0,readpos;
	int allocd=220500;
	
	OggVorbis_File vf;
	if(ov_myfopen((char *) fn.c_str(), &vf) < 0) return 0;
	int channels = ov_info(&vf,0)->channels;
	int samplerate = ov_info(&vf,0)->rate;
	int cnt=effects.count;
	INFO(AUDIO,"OGG load effect %d: chn:%d, rate=%d\n", cnt, channels, samplerate);
	buf[0]=buf[1]=0;
	dorealloc(effects.data[cnt],allocd);
	readpos=256;
	while (1)
	{
		int ret=ov_read(&vf,(char *)(buf+2),8192,0,2,1,&bs);
		if (!ret) break;
		int locchn=ov_info(&vf,-1)->channels;
		int locrate=ov_info(&vf,-1)->rate;
		int samples=ret/2/locchn;
		int step=locrate*256/obtained.freq;
		DBG(AUDIO,"Read %d chn:%d sr:%d\n", samples, locchn, locrate);
		for (i=0; i<samples; i++)
		{
			v=0;
			for (j=0; j<locchn; j++) v+=buf[i*locchn+j];
			v=v/locchn;
			buf[i]=(int16_t) v;
		}
		while (readpos<(samples+1)*256)
		{
			readpos+=step;
			if (pos>=allocd)
			{
				allocd=allocd*2;
				dorealloc(effects.data[cnt],allocd);
			}
			effects.data[cnt][pos++]=interpolate(buf,readpos);
		}
		readpos-=samples*256;
		buf[0]=buf[samples];
		buf[1]=buf[samples+1];
	}
	dorealloc(effects.data[cnt],pos+padding);
	for (i=0; i<padding; i++) effects.data[i+pos]=0;
	INFO(AUDIO,"Loaded effect, len=%d\n", pos);
	effects.len[cnt]=pos+padding;
	ov_clear(&vf);
	return ++effects.count;
}

int song_start(string path, int paused)
{
	int len=path.length();
	if (len>2047) len=2047;
	playing.startpaused=paused;
	INFO(AUDIO,"Song start: >%s<\n", path);
	strncpy(playing.songname,path.c_str(),len);
	playing.songname[len]=0;
	playing.songname[2048]=0;
	playing.refreshsong=1;
	// need some thread protection here, in case we read this string at the same time
	// (unlikely, but just to be thorough)
}

void song_stop()
{
	playing.songname[0]=0;
	playing.refreshsong=1;
}

void tPlaying::close_song()
{
	decodepos=0;
	playing=0;
	close_ovfile(&ov_song);
}

void tPlaying::open_song()
{
	// use char arrays here for thread safety reasons
	DBG(AUDIO,"opening song: >%s<\n" ,songname);
	char namelocal[2148];
	int i;
	strncpy(namelocal,songname,2048);
	namelocal[2048]=0;
	
	decodepos=0;
	ogg_bs=0;
	sisopen=0;
	// zero length by default
	stopsat=0;
	
	SDL_LockAudio();
	playpos=0;
	pause=startpaused;
	SDL_UnlockAudio();
	songstarted=0;
	int l=strlen(namelocal);
	if (!l) return;
	if (ov_myfopen(namelocal, &ov_song) >=0) 
	{ 
		sisopen=1; 
		stopsat=1000000000; 
	}
	
	// we do this here, otherwise the
	// callback might clear them if stopsat[]
	// is not yet initialized
	songended=0;	
	stalled=1;
}

int tPlaying::decode(OggVorbis_File *ovf)
{
	int i;
	int16_t buf[4112];
	int target=4096;
	int target2=decode_ticks*obtained.freq/250;
	if (target2>target) target=target2; 
	// decode at least 4 times as much as it took to render one frame
	int target3=SONG_BUFFER_SIZE-SONG_MARGIN-(decodepos-playpos);
	if (target3<target) target=target3; 
	DBG(AUDIO,"Filling song buffer, targets are: %d %d %d\n", target, target2, target3);
	int pos=decodepos;
	while (target>0)
	{
		if (!sisopen)
		{
			// when song is not open, just fill with zeros
			// this may be wasteful, but it's not going to be
			// any slower than actually decoding the song
			for (i=0; i<target; i++)
			{
				buffer[0][pos%SONG_BUFFER_SIZE]=0;
				buffer[1][pos%SONG_BUFFER_SIZE]=0;
				pos++;
			}
			decodepos=pos;
			target=0;
			break;
		}
		int ret=ov_read(ovf,(char *)buf,8192,0,2,1,&ogg_bs);
		if (ret<=0) 
		{
			stopsat=pos;
			sisopen=0;
			close_ovfile(ovf);
			continue;
		}
		int locchn=ov_info(ovf,-1)->channels;
		int locrate=ov_info(ovf,-1)->rate;
		int samples=ret/2/locchn;
		int chn2=locchn>1?1:0;
		
		DBG(AUDIO,"Read %d chn:%d sr:%d\n", samples, locchn, locrate);
		for (i=0; i<samples; i++)
		{
			buffer[0][pos%SONG_BUFFER_SIZE]=buf[i*locchn];
			buffer[1][pos%SONG_BUFFER_SIZE]=buf[i*locchn+chn2];				
			pos++;
		}
		decodepos=pos;
		target-=samples;
	}
	return 0;
}

void tPlaying::close_ovfile(OggVorbis_File *ovf)
{
	if (sisopen) return;
	sisopen=0;
	ov_clear(ovf);
}

void tPlaying::some_predecode()
{
	int thistime=SDL_GetTicks();
	decode_ticks=thistime-decode_lasttime;
	if (decode_ticks>500) decode_ticks=500;
	decode_lasttime=thistime;
	decode(&ov_song);
}

void audio_yield()
{
	if (playing.refreshsong)
	{
		playing.close_song();
		if (playing.songname[0]) playing.open_song();
		playing.refreshsong=0;
	}
	playing.some_predecode();
}

double song_time()
{
	return 0;
}
